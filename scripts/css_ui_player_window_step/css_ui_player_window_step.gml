function css_ui_player_window_step() {
	if (obj_css_ui.state == CSS_STATE.normal)
		{
		//Exit out if it's a CPU
		if (css_player_get(index, CSS_PLAYER.is_cpu)) then exit;
	
		//Find the correct cursor
		if (cursor_number == noone)
			{
			var _selector;
			for(var i = 0; i < ds_list_size(obj_css_ui.cursors); i++)
				{
				var _cursor = obj_css_ui.cursors[| i];
				var _index = _cursor[CSS_CURSOR.index];
				if (_index == index)
					{
					_selector = i;
					break;
					}
				}
			cursor_number = _selector;
			}
		
		//Inputs
		var _confirm = false;
		var _option = false;
		var _cancel = false;
		var _delete = false;
		var _sticklh, _rl, _sticklv, _ud;
		var _cursor = obj_css_ui.cursors[| cursor_number];
		var _device = _cursor[CSS_CURSOR.device];
		var _device_type = _cursor[CSS_CURSOR.device_type];
		
		if (_device_type == DEVICE.controller)
			{
			_confirm = gamepad_button_check_pressed(_device, menu_confirm_button);
			_option = gamepad_button_check_pressed(_device, menu_option_button);
			_cancel = gamepad_button_check_pressed(_device, menu_cancel_button);
			_delete = gamepad_button_check_pressed(_device, menu_delete_button);
			_sticklh = abs(gamepad_axis_value(_device, gp_axislh)) > stick_flick_amount;
			_sticklv = abs(gamepad_axis_value(_device, gp_axislv)) > stick_flick_amount;
			_rl = sign(gamepad_axis_value(_device, gp_axislh));
			_ud = sign(gamepad_axis_value(_device, gp_axislv));
			}
		else if (_device_type == DEVICE.keyboard)
			{
			_confirm = keyboard_check_pressed(menu_confirm_key);
			_option = keyboard_check_pressed(menu_option_key);
			_cancel = keyboard_check_pressed(menu_cancel_key);
			_delete = keyboard_check_pressed(menu_delete_key);
			_sticklh = sign(keyboard_check(menu_right_key) + keyboard_check(menu_left_key));
			_sticklv = sign(keyboard_check(menu_down_key) + keyboard_check(menu_up_key));
			_rl = keyboard_check(menu_right_key) - keyboard_check(menu_left_key);
			_ud = keyboard_check(menu_down_key) - keyboard_check(menu_up_key);
			}
	
		//States
		switch(state)
			{
			case CSS_PLAYER_WINDOW_STATE.select_character:
				//Recall token
				if (_cancel && _cursor[CSS_CURSOR.holding] == noone)
					{
					_cursor[@ CSS_CURSOR.holding] = index;
					}
				break;
			case CSS_PLAYER_WINDOW_STATE.select_profile:
				//Inputs
				var _position = css_player_list_position(_cursor[CSS_CURSOR.index]);
		
				//Scrolling
				if (_sticklv != 0 && Virtual_Button_Hold(obj_css_ui.vc, _position, VB.sticklv))
					{
					profile_current = modulo(profile_current + _ud, ds_list_size(engine().profiles));
					while(profile_current > profile_scroll + 3) 
						{
						profile_scroll++;
						}
					while(profile_current < profile_scroll) 
						{
						profile_scroll--;
						}
					}
		
				//Actions
				if (_confirm)
					{
					css_player_set(index, CSS_PLAYER.profile, profile_current);
					state = CSS_PLAYER_WINDOW_STATE.select_character;
					//Re activate cursor
					css_ui_cursor_set_active(index, true);
					break;
					}
				if (_cancel)
					{
					state = CSS_PLAYER_WINDOW_STATE.select_character;
					//Re activate cursor
					css_ui_cursor_set_active(index, true);
					break;
					}
				if (_option)
					{
					//New profile
					state = CSS_PLAYER_WINDOW_STATE.create_profile;
					break;
					}
				if (_delete)
					{
					//Delete profiles. Cannot delete auto profiles or profiles used by other players
					if (!Profile_Get(profile_current, PROFILE.autogenerated))
						{
						var _used = false;
						for(var i = 0; i < css_number_of_players(); i++)
							{
							if (css_player_get(css_player_index(i), CSS_PLAYER.profile) == profile_current)
								{
								_used = true;
								break;
								}
							}
						if (!_used)
							{
							Profile_Destroy(profile_current);
							//Make sure the profile indexes still line up correctly
							var _deleted_profile = profile_current;
							//Make sure other players' cursors are not on an undefined profile
							with(obj_css_player_window)
								{
								var _profile_number = css_player_get(index, CSS_PLAYER.profile);
								if (_profile_number > _deleted_profile)
									{
									css_player_set(index, CSS_PLAYER.profile, _profile_number - 1);
									}
								profile_scroll = 0;
								profile_current = modulo(profile_current, ds_list_size(engine().profiles));
								}
							//Save profiles
							Profile_Save_All();
							}
						break;
						}
					}
				break;
			case CSS_PLAYER_WINDOW_STATE.create_profile:
				//Inputs
				var _position = css_player_list_position(_cursor[CSS_CURSOR.index]);
		
				//Scrolling
				if (_sticklh != 0 && Virtual_Button_Hold(obj_css_ui.vc, _position, VB.sticklh))
					{
					profile_new_letter = modulo(profile_new_letter + _rl, array_length(profile_possible_chars));
					}
			
				//Adding a letter
				if (_confirm)
					{
					if (string_length(profile_new_name) < profile_name_max_length)
						{
						profile_new_name += profile_possible_chars[profile_new_letter];
						}
					}
				//Deleting a letter
				if (_cancel)
					{
					profile_new_name = string_copy(profile_new_name, 0, string_length(profile_new_name) - 1);
					}
				//Cancel
				if (_delete)
					{
					state = CSS_PLAYER_WINDOW_STATE.select_profile;
					profile_new_letter = 0;
					profile_new_name = "";
					break;
					}
				//Creating the new profile
				if (_option)
					{
					var _profile = Profile_Create(profile_new_name, 0, 0, custom_controls_create(), [], 0, false);
					css_player_set(index, CSS_PLAYER.profile, _profile);
					state = CSS_PLAYER_WINDOW_STATE.select_character;
					//Re activate cursor
					css_ui_cursor_set_active(index, true);
					profile_new_letter = 0;
					profile_new_name = "";
					//Save profiles
					Profile_Save_All();
					break;
					}
				break;
			case CSS_PLAYER_WINDOW_STATE.controls:
				//Inputs
				var _position = css_player_list_position(_cursor[CSS_CURSOR.index]);
	
				//Scrolling
				if (_sticklv != 0 && Virtual_Button_Hold(obj_css_ui.vc, _position, VB.sticklv))
					{
					var _length;
					if (_device_type == DEVICE.controller) then _length = CC_INPUT_CONTROLLER.length;
					else _length = CC_INPUT_KEYBOARD.length;
			
					//Add in the special control settings (SCS)
					_length += 7;
			
					custom_controls_current = modulo(custom_controls_current + _ud, _length);
					while(custom_controls_current > custom_controls_scroll + 3) 
						{
						custom_controls_scroll++;
						}
					while(custom_controls_current < custom_controls_scroll) 
						{
						custom_controls_scroll--;
						}
					}
		
				//Cancel
				if (_cancel)
					{
					state = CSS_PLAYER_WINDOW_STATE.select_character;
					//Re activate cursor
					css_ui_cursor_set_active(index, true);
					//Save profiles
					Profile_Save_All();
					break;
					}
			
				//Remap / Toggle
				if (_confirm)
					{
					var _length;
					if (_device_type == DEVICE.controller) then _length = CC_INPUT_CONTROLLER.length;
					else _length = CC_INPUT_KEYBOARD.length;
					//Inputs
					if (custom_controls_current < _length)
						{
						state = CSS_PLAYER_WINDOW_STATE.control_set;
						custom_controls_choosing = false;
						custom_controls_array = [];
						}
					//SCS
					else
						{
						var _scs_array = scs_convert_from_int(custom_controls_map[? "SCS"]);
						var _n = (custom_controls_current - _length);
						if (_n < 6)
							{
							_scs_array[@ _n] = !_scs_array[_n];
							}
						else
							{
							_scs_array[@ 6] = modulo(_scs_array[6] + 1, INPUT.length);
							}
						custom_controls_map[? "SCS"] = scs_convert_to_int(_scs_array);
						}
					break;
					}
				break;
			case CSS_PLAYER_WINDOW_STATE.control_set:
				var _any_input = false;
				var _any_held = false;
				var _stop = false;
		
				//Inputs
				if (_device_type == DEVICE.controller)
					{
					//Control sticks don't count
					_any_input = controller_any_input(_device, 1, true);
					_any_held = controller_any_input(_device, 1, false);
					_stop = gamepad_button_check_pressed(_device, gp_select);
					}
				else if (_device_type == DEVICE.keyboard)
					{
					_any_input = keyboard_check_pressed(vk_anykey);
					_any_held = keyboard_check(vk_anykey);
					_stop = keyboard_check_pressed(vk_backspace);
					}
			
				//Actions
				if (_any_input)
					{
					custom_controls_choosing = true;
			
					//Add to the array
					var _currently_held = [];
					if (_device_type == DEVICE.controller)
						{
						//Limit to 4 buttons per input
						if (array_length(custom_controls_array) < 4)
							{
							_currently_held = controller_get_input(_device);
							for(var i = 0; i < array_length(_currently_held); i++)
								{
								var _exists = false;
								for(var m = 0; m < array_length(custom_controls_array); m++)
									{
									if (custom_controls_array[m] == _currently_held[i])
										{
										_exists = true;
										break;
										}
									}
								if (!_exists)
									{
									custom_controls_array[array_length(custom_controls_array)] = _currently_held[i];
									}
								}
							}
						}
					else if (_device_type == DEVICE.keyboard)
						{
						custom_controls_array = [keyboard_lastkey];
						}
					}
				else if (!_any_held && custom_controls_choosing)
					{
					custom_controls_choosing = false;
					state = CSS_PLAYER_WINDOW_STATE.controls;
			
					//Set the new controls
					var _inputs = custom_controls_map[? string(_device_type)];
					var _list = _inputs[| custom_controls_current];
					ds_list_recreate(_list, custom_controls_array);
					break;
					}
			
				//Stopping / Clearing the controls
				if (_stop)
					{
					custom_controls_choosing = false;
					state = CSS_PLAYER_WINDOW_STATE.controls;
					var _inputs = custom_controls_map[? string(_device_type)];
					var _list = _inputs[| custom_controls_current];
					ds_list_clear(_list);
					break;
					}
				break;
			case CSS_PLAYER_WINDOW_STATE.playtesting:
				break;
			case CSS_PLAYER_WINDOW_STATE.ready:
				//Nothing
				break;
			}
		}


}
